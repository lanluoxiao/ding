{"./":{"url":"./","title":"封面","keywords":"","body":"顶功 · 集萃 2005 年以来，随着戴石麟先生的顶功输入方案开山之作「声笔码」及「声笔飞码」横空出世，输入法界的新时代悄然来临。越来越多的人从质疑到了解再到恍然大悟、为己所用，一场轰轰烈烈的革命随之爆发。 何为顶功？有哪些成熟的作品？如何亲手制作一个？这些是本文档要回答的。愿您也能感受到顶功方案的趣味。 析顶功之理，赏万码之韵。 更新内容 相比于 2016 年的 Word 版本，本文档做了如下改动： 引入「唯一码」「前缀码」等信息论的分析角度； 使用了更通俗的文章风格，加入了示例图； 添加了近几年新出的方案； 附录了几篇论文，激活您更深层的思考。 阅读方式 在 本仓库 GitHub 页面 在线阅读； 从 本仓库发行页 下载 PDF 或 EPUB 格式的电子书离线阅读； 从 百度网盘 下载 PDF 或 EPUB 格式的电子书离线阅读。 联系作者 如果您对本文档有意见或建议，请在本仓库中提交 issue，也可以发送电子邮件给 蓝落萧 或 Yb。 开源协议 本文档遵循 GPLv3 协议。 Copyright© 2020-present, lanluoxiao "},"introduction/":{"url":"introduction/","title":"引言","keywords":"","body":"引言 本节中，我们将介绍一些基本概念，使读者对于顶功的介绍做好准备。 汉字的编码输入 自上世纪七十年代以来，计算机技术在我国的发展和普及使得汉字的信息处理成为一项关系到文化发展与社会进步的重要任务。其中，以恰当的方式将汉字输入计算机是汉字信息处理所面临的首要挑战，这是因为汉字结构复杂、数量繁多，不能像拼音文字一样直接输入计算机，而是要通过编码的方式输入计算机。 在汉字编码输入中，被编码的对象可以是单个汉字，可以是词语和短句，也可以是汉语标点符号和其他特殊符号。简便起见，我们将被编码的对象统称为消息，所有消息的集合称为消息集。例如，GB/T 2312–1980 规范gb2312中的 6763 个汉字组成了一个消息集，现代汉语词典中的所有词语也组成了一个消息集。 gb2312. 参见百度百科 https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%94%A8%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86/8074272?fromtitle=GB2312&fromid=483170 ↩ 符号、符号集与符号串 所谓编码，就是将汉字用一系列符号来表示。我们将一系列符号输入计算机，然后计算机将这些符号重新还原成汉字，这样就实现了汉字的输入。符号的选取多种多样，常见的选择是使用 26 个拉丁字母 a,b,⋯,z\\mathrm{a, b,\\cdots, z}a,b,⋯,z，但也可以使用键盘上的其他符号。对于一个特定的编码输入方案来说，它用到的全部符号构成的集合称为符号集。 给定一个符号集 SSS，我们称由零个、一个或多个 SSS 中的符号顺次相连产生的序列为 SSS 上的符号串（简称串）。特别地，我们记零个符号对应的串为 ε\\varepsilonε。例如，ε\\varepsilonε, a, z, abc, sdfg 都是 26 个拉丁字母 a,b,⋯,z\\mathrm{a, b,\\cdots, z}a,b,⋯,z 上的符号串。 语言和码 给定一个符号集 SSS，我们称由零个、一个或多个 SSS 上的符号串构成的集合为一个 SSS 上的语言。 给定一个消息集 MMM 和一个语言 LLL，若对于 MMM 中的每一个消息 mmm，我们都可以为它指定 LLL 中的一个符号串 lll 与之对应，那么我们就构造了一个码。形式化地来说，一个码是一个消息集到语言的映射： f:M→L;f(m)=l f:M\\to L;\\quad f(m) = l f:M→L;f(m)=l 非奇异码 称一个码是非奇异码，如果该码是一个单射。 "},"definition/":{"url":"definition/","title":"定义","keywords":"","body":"定义 串的运算 一个串 aaa 的长度定义为它包含的字符个数，记为 ∣a∣|a|∣a∣。 连接运算 给定一符号集 SSS，我们可以定义 SSS 上串的连接运算，运算符记为 ×\\times×：若 a,ba,ba,b 是 SSS 上的串，那么 a×ba\\times ba×b 表示两个串顺次相连产生的新串。在不引起歧义时，连接运算的运算符也可以省略不写，如 ababab。串的连接运算具有以下性质： 不满足乘法交换律，例如 abc×de=abcde\\mathrm{abc\\times de=abcde}abc×de=abcde，而 de×abc=deabc\\mathrm{de\\times abc=deabc}de×abc=deabc； 满足乘法结合律，例如 abc×(de×f)=abcdef\\mathrm{abc\\times(de\\times f)=abcdef}abc×(de×f)=abcdef，而 (abc×de)×f=abcdef\\mathrm{(abc\\times de)\\times f=abcdef}(abc×de)×f=abcdef； 对所有的串 aaa，都满足 εa=aε=a\\varepsilon a=a\\varepsilon=aεa=aε=a，其中 ε\\varepsilonε 是空字符串； 前缀和后缀 我们称串 aaa 是串 bbb 的前缀，如果存在串 ccc，使得 b=acb=acb=ac。我们用 a⊏ba\\sqsubset ba⊏b 来表示串 aaa 是串 bbb 的前缀这一关系。例如，hel 是 hello 的一个前缀。 我们称串 aaa 是串 bbb 的后缀，如果存在串 ccc，使得 b=cab=cab=ca。我们用 b⊐ab\\sqsupset ab⊐a 来表示串 aaa 是串 bbb 的后缀这一关系。例如，ello 是 hello 的一个后缀。 特别地，对于任一符号串 aaa，aaa 和 ϵ\\epsilonϵ 都是 aaa 的前缀，也都是 aaa 的后缀。 唯一可译码 在一个非奇异码中，虽然我们规定消息集到语言的映射是单射，但还并不能保证计算机能对输入的符号进行正确的解码。这是因为，在一次输入会话中，我们将一个消息序列中的消息依次进行编码，然后将得到的符号串连接在一起作为一个整体输入，因而解码时对符号串的划分可能存在歧义。 对于一个非奇异码来说，如果其语言包含的串无论如何相互连接，得到的长串都仅能以一种方式分解为串的乘积，则称这个码为唯一可译码。形式化地，如果非奇异码 f:M→Lf:M\\to Lf:M→L 中 LLL 满足 p1p2⋯pn=q1q2⋯qm,pi∈L,qj∈L,∀i=1,⋯,n;j=1,⋯,m⇒n=m,pi=qi,∀i=1,⋯,n \\begin{aligned} p_1p_2\\cdots p_n=q_1q_2\\cdots q_m, p_i\\in L, q_j\\in L, \\forall i=1,\\cdots, n; j=1,\\cdots,m \\\\ \\Rightarrow n=m,p_i=q_i,\\forall i=1,\\cdots,n \\end{aligned} ​p​1​​p​2​​⋯p​n​​=q​1​​q​2​​⋯q​m​​,p​i​​∈L,q​j​​∈L,∀i=1,⋯,n;j=1,⋯,m​⇒n=m,p​i​​=q​i​​,∀i=1,⋯,n​​ 唯一可译码的 Kraft–McMillan 不等式 定理 给定唯一可译码 f:M→Lf:M\\to Lf:M→L，LLL 对应的符号集 SSS 的大小为 rrr，并且语言 LLL 所包含的 nnn 个符号串 l1,⋯,lnl_1,\\cdots,l_nl​1​​,⋯,l​n​​ 的长度分别为 w1,⋯,wnw_1,\\cdots,w_nw​1​​,⋯,w​n​​，那么 ∑i=1nr−wi≤1 \\sum_{i=1}^nr^{-w_i}\\le 1 ​i=1​∑​n​​r​−w​i​​​​≤1 证明参考附录。 Kraft-McMillan 不等式给出了唯一可译码的一个必要条件，但它并不是一个充分条件。下面我们探讨一类容易构造的唯一可译码。 前缀码 我们称一个码 f:M→Lf:M\\to Lf:M→L 是前缀码，如果 LLL 中任两个串 aaa 和 bbb 都满足 aaa 不是 bbb 的前缀、bbb 也不是 aaa 的前缀。形式上地， a,b∈L⇒¬(a⊏b)∧¬(b⊏a) a,b \\in L \\Rightarrow \\neg (a\\sqsubset b) \\wedge \\neg (b\\sqsubset a) a,b∈L⇒¬(a⊏b)∧¬(b⊏a) 所有前缀码都是唯一码。（需要说明） 然而，不是所有唯一可译码都是前缀码。假设消息集 MMM 包含两个消息，符号集为 {0,1}\\{0,1\\}{0,1}，我们来看这个语言： L={10,1} L=\\{10,1\\} L={10,1} （一定的论证）所以，它也是唯一可译码。 顶功码 我们称所有不是前缀码的唯一可译码为顶功码。 唯一可译码在线验证 检验一个码是否为前缀码是容易的，但是检验是否为唯一可译码则不那么容易。在这里我们提供一个在线应用对其进行检测。 前缀码与顶功码的等价性 我们定义码 f:M→Lf:M\\to Lf:M→L 和码 g:M→L′g:M\\to L'g:M→L​′​​ 等价，如果它们的语言 L,L′L,L'L,L​′​​ 共享了同一个符号集 SSS，并且存在一个双射 σ:L→L′\\sigma:L\\to L'σ:L→L​′​​，将 LLL 中的每一个串 aaa 映成 bbb 时 aaa 和 bbb 具有相同种类和数量的符号，也即 bbb 是 aaa 的一个重新排列。 由于前缀码总是比顶功码更易于理解，我们总希望将顶功码通过等价关系转化为前缀码加以研究。虽然我们尚未进行证明，但是我们接下来默认这一事实的正确性：对于任意一个顶功码，可以找到一个前缀码与之等价。 "},"design/":{"url":"design/","title":"方案设计","keywords":"","body":"方案设计 汉字特征概述 为了实现汉字编码的易学易用，我们通常将汉字的某些特征（如声母、韵母、声调、笔画和字根等等）提取出来用于编码。对于一个特定的特征来说，它可以取很多种不同的值，我们可以对这些值进行枚举，枚举得到的每种值称为一个字元。如： 特征「声母」可以枚举得到【b p m f d t n l g k h j q x zh ch sh r z s c y w '】这 24 个字元； 特征「第一笔」可以枚举得到【一，丨，丿，丶，乙】这 5 个字元。 一个特征枚举得到所有字元的总和称为该特征的字元集，如「24 种声母」、「5 种笔画」都是字元集。在有些情况下，汉字的不同特征可能对应着相同的字元集，例如「第一笔」和「最后一笔」的字元集是相同的。 基于汉字特征的编码 提取汉字特征 ccc 和相应的字元集 RRR 后，若给定一个可用的符号集 SSS，我们可以选取一个子集 T⊂ST\\subset ST⊂S，并建立映射 φ:R→T\\varphi:R\\to Tφ:R→T 来将这些字元与符号关联起来，这样的映射称为一个布局。 通常，我们要提取一个汉字的多个特征才能完成编码。在给定的输入方案下，提取的全部特征构成的序列称为全码（例如小鹤双拼的单字全码为【声韵形形】）。输入方案也可能对方案进行部分提取，得到的序列称为简码。 用字符集子集的直积表示语言的子集 由于汉字特征提取过程的特点，不同长度和不同性质的编码对应的符号串往往在语言中的分布是非常有规律的，因此我们可以将一类编码用直积来表述。 同构原理 我们称 S=⋃i=1NSSiS=\\bigcup_{i=1}^{N_S} S_iS=⋃​i=1​N​S​​​​S​i​​ 是符号集 SSS 的一个划分，如果 ∀i≠j,Si∩Sj=∅\\forall i\\ne j, S_i\\cap S_j=\\emptyset∀i≠j,S​i​​∩S​j​​=∅。对于一个码 f:M→Lf:M\\to Lf:M→L 来说，如果语言 LLL 可以写成如下形式： L=⋃i=1NLLi;Li=∏j=1miSij L=\\bigcup_{i=1}^{N_L} L_i;\\quad L_i=\\prod_{j=1}^{m_i}S_{ij} L=​i=1​⋃​N​L​​​​L​i​​;L​i​​=​j=1​∏​m​i​​​​S​ij​​ 那么我们可以对这个码建立一个简化的表达方式。 首先，我们建立一个大小为 NSN_SN​S​​ 的新符号集 S′S'S​′​​，将划分得到的每个子集对应成一个符号；其次，我们建立一个大小为 NLN_LN​L​​ 的语言 L′L'L​′​​，其元素为原先的各个 LiL_iL​i​​ 中各个直积的集合对应的新符号构成的串；最后，我们把原先对应于各个 LiL_iL​i​​ 的消息集子集分别对应到一个新消息，构成的集合为 M′M'M​′​​，则 f′:M′→L′ f':M'\\to L' f​′​​:M​′​​→L​′​​ 也是一个码。容易验证，这个码和原来的码同时具有或不具有非奇异性、唯一性、前缀性和顶功性等性质。因此，在以下章节中我们将使用简化的同构码讲解各种顶功方案。 "},"implementation/":{"url":"implementation/","title":"方案实现","keywords":"","body":"方案实现 "},"appendix/proof.html":{"url":"appendix/proof.html","title":"数学结果的证明","keywords":"","body":"数学结果的证明 Kraft-McMillan 不等式 定理 给定唯一可译码 f:M→Lf:M\\to Lf:M→L，LLL 对应的符号集 SSS 的大小为 rrr，并且语言 LLL 所包含的 nnn 个符号串 l1,⋯,lnl_1,\\cdots,l_nl​1​​,⋯,l​n​​ 的长度分别为 w1,⋯,wnw_1,\\cdots,w_nw​1​​,⋯,w​n​​，那么 ∑i=1nr−wi≤1 \\sum_{i=1}^nr^{-w_i}\\le 1 ​i=1​∑​n​​r​−w​i​​​​≤1 证明 我们记等式左方数值为 KKK。现在给定任意正整数 mmm，我们计算 Km=∑i1=1n∑i2=1n⋯∑im=1nr−wi1−wi2−⋯−win K^m=\\sum_{i_1=1}^n\\sum_{i_2=1}^n\\cdots\\sum_{i_m=1}^n r^{-w_{i_1}-w_{i_2}-\\cdots -w_{i_n}} K​m​​=​i​1​​=1​∑​n​​​i​2​​=1​∑​n​​⋯​i​m​​=1​∑​n​​r​−w​i​1​​​​−w​i​2​​​​−⋯−w​i​n​​​​​​ 将上式按 wi1+⋯+winw_{i_1}+\\cdots+w_{i_n}w​i​1​​​​+⋯+w​i​n​​​​ 的大小重新整理，可以得到 Km=∑l=1mlmaxqlr−l K^m=\\sum_{l=1}^{ml_{\\max}}q_lr^{-l} K​m​​=​l=1​∑​ml​max​​​​q​l​​r​−l​​ 其中，lmaxl_{\\max}l​max​​ 为语言 LLL 中最长串的长度，qlq_lq​l​​ 为 wi1+⋯+win=lw_{i_1}+\\cdots+w_{i_n}=lw​i​1​​​​+⋯+w​i​n​​​​=l 的项数。由于该码是唯一可译码，这样的项必然不能超过 rlr^lr​l​​ 个（如不然，将会出现两种不同的组合方式得到同一个串的情况），因此有 Km≤∑l=1mlmaxrlr−l=mlmax K^m\\le\\sum_{l=1}^{ml_{\\max}}r^lr^{-l}=ml_{\\max} K​m​​≤​l=1​∑​ml​max​​​​r​l​​r​−l​​=ml​max​​ 接下来我们使用反证法：不妨设 K>1K>1K>1，记 K=1+δK=1+\\deltaK=1+δ。当 mmm 充分大以至于 m>1+2lmax/δ2m>1+2l_{\\max}/\\delta^2m>1+2l​max​​/δ​2​​ 时，则有 Km≥12m(m−1)δ2>mlmax K^m\\ge\\frac12m(m-1)\\delta^2>ml_{\\max} K​m​​≥​2​​1​​m(m−1)δ​2​​>ml​max​​ 矛盾。因此必须 K≤1K\\le1K≤1。 "}}